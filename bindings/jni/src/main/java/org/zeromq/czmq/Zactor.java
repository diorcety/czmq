/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq;

public class Zactor implements AutoCloseable{
    static {
        try {
            System.loadLibrary ("czmqjni");
        }
        catch (Exception e) {
            System.exit (-1);
        }
    }

    public interface ZactorFn {
        void  callback (Zsock pipe, long args);
    }

    public static class _ZactorFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZactorFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZactorFn (ZactorFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.VOID, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.POINTER, com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            inner.callback(new Zsock(buffer.getAddress(0)), buffer.getLong(1));
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZactorFn zactor_fn(ZactorFn inner) {
        return inner != null ? new _ZactorFn(inner) : null;
    }

    public interface ZactorDestructorFn {
        void  callback (Zactor self);
    }

    public static class _ZactorDestructorFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZactorDestructorFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZactorDestructorFn (ZactorDestructorFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.VOID, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.POINTER}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            inner.callback(new Zactor(buffer.getAddress(0)));
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZactorDestructorFn zactor_destructor_fn(ZactorDestructorFn inner) {
        return inner != null ? new _ZactorDestructorFn(inner) : null;
    }


    public long self;

    /*
    Create a new actor passing arbitrary arguments reference.
    */
    native static long __new (long task, long args);
    public Zactor (_ZactorFn task, long args) {
        /*  TODO: if __new fails, self is null...            */
        self = __new (task.getAddress(), args);
    }
    public Zactor (long pointer) {
        self = pointer;
    }
    /*
    Destroy an actor.
    */
    native static void __destroy (long self);
    @Override
    public void close () {
        __destroy (self);
        self = 0;
    }

    /*
    Send a zmsg message to the actor, take ownership of the message
    and destroy when it has been sent.
    */
    native static int __send (long self, long msgP);
    public int send (Zmsg msgP) {
        return __send (self, msgP.self);
    }
    /*
    Receive a zmsg message from the actor. Returns NULL if the actor
    was interrupted before the message could be received, or if there
    was a timeout on the actor.
    */
    native static long __recv (long self);
    public Zmsg recv () {
        return new Zmsg (__recv (self));
    }
    /*
    Probe the supplied object, and report if it looks like a zactor_t.
    */
    native static boolean __is (long self);
    public static boolean is (long self) {
        return __is (self);
    }
    /*
    Probe the supplied reference. If it looks like a zactor_t instance,
    return the underlying libzmq actor handle; else if it looks like
    a libzmq actor handle, return the supplied value.
    */
    native static long __resolve (long self);
    public static long resolve (long self) {
        return __resolve (self);
    }
    /*
    Return the actor's zsock handle. Use this when you absolutely need
    to work with the zsock instance rather than the actor.
    */
    native static long __sock (long self);
    public Zsock sock () {
        return new Zsock (__sock (self));
    }
    /*
    Change default destructor by custom function. Actor MUST be able to handle new message instead of default $TERM.
    */
    native static void __setDestructor (long self, long destructor);
    public void setDestructor (_ZactorDestructorFn destructor) {
        __setDestructor (self, destructor.getAddress());
    }
    /*
    Self test of this class.
    */
    native static void __test (boolean verbose);
    public static void test (boolean verbose) {
        __test (verbose);
    }
}
