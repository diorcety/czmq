/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq;

public class Zhashx implements AutoCloseable{
    static {
        try {
            System.loadLibrary ("czmqjni");
        }
        catch (Exception e) {
            System.exit (-1);
        }
    }

    public interface ZhashxDestructorFn {
        void  callback (long item);
    }

    public static class _ZhashxDestructorFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZhashxDestructorFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZhashxDestructorFn (ZhashxDestructorFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.VOID, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            inner.callback(buffer.getLong(0));
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZhashxDestructorFn zhashx_destructor_fn(ZhashxDestructorFn inner) {
        return inner != null ? new _ZhashxDestructorFn(inner) : null;
    }

    public interface ZhashxDuplicatorFn {
        long  callback (long item);
    }

    public static class _ZhashxDuplicatorFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZhashxDuplicatorFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZhashxDuplicatorFn (ZhashxDuplicatorFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.SLONG, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            long ret;
            ret =  inner.callback(buffer.getLong(0));
            buffer.setLongReturn(ret);
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZhashxDuplicatorFn zhashx_duplicator_fn(ZhashxDuplicatorFn inner) {
        return inner != null ? new _ZhashxDuplicatorFn(inner) : null;
    }

    public interface ZhashxComparatorFn {
        int  callback (long item1, long item2);
    }

    public static class _ZhashxComparatorFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZhashxComparatorFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZhashxComparatorFn (ZhashxComparatorFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.SINT, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.SLONG, com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            int ret;
            ret =  inner.callback(buffer.getLong(0), buffer.getLong(1));
            buffer.setIntReturn(ret);
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZhashxComparatorFn zhashx_comparator_fn(ZhashxComparatorFn inner) {
        return inner != null ? new _ZhashxComparatorFn(inner) : null;
    }

    public interface ZhashxFreeFn {
        void  callback (long data);
    }

    public static class _ZhashxFreeFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZhashxFreeFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZhashxFreeFn (ZhashxFreeFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.VOID, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            inner.callback(buffer.getLong(0));
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZhashxFreeFn zhashx_free_fn(ZhashxFreeFn inner) {
        return inner != null ? new _ZhashxFreeFn(inner) : null;
    }

    public interface ZhashxHashFn {
        long  callback (long key);
    }

    public static class _ZhashxHashFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZhashxHashFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZhashxHashFn (ZhashxHashFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.SLONG, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            long ret;
            ret =  inner.callback(buffer.getLong(0));
            buffer.setLongReturn(ret);
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZhashxHashFn zhashx_hash_fn(ZhashxHashFn inner) {
        return inner != null ? new _ZhashxHashFn(inner) : null;
    }

    public interface ZhashxSerializerFn {
        String  callback (long item);
    }

    public static class _ZhashxSerializerFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZhashxSerializerFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZhashxSerializerFn (ZhashxSerializerFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.POINTER, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            String ret;
            ret =  inner.callback(buffer.getLong(0));
            java.nio.ByteBuffer buf = java.nio.charset.Charset.defaultCharset().encode(ret);
            long memory = com.kenai.jffi.MemoryIO.getInstance().allocateMemory(buf.remaining() + 1, false);
            com.kenai.jffi.MemoryIO.getInstance().putZeroTerminatedByteArray(memory, buf.array(), buf.arrayOffset() + buf.position(), buf.remaining());
            buffer.setAddressReturn(memory);
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZhashxSerializerFn zhashx_serializer_fn(ZhashxSerializerFn inner) {
        return inner != null ? new _ZhashxSerializerFn(inner) : null;
    }

    public interface ZhashxDeserializerFn {
        long  callback (String itemStr);
    }

    public static class _ZhashxDeserializerFn implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZhashxDeserializerFn inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZhashxDeserializerFn (ZhashxDeserializerFn inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.SLONG, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.POINTER}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            long ret;
            ret =  inner.callback(java.nio.charset.Charset.defaultCharset().decode(java.nio.ByteBuffer.wrap(com.kenai.jffi.MemoryIO.getInstance().getZeroTerminatedByteArray(buffer.getAddress(0)))).toString());
            buffer.setLongReturn(ret);
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZhashxDeserializerFn zhashx_deserializer_fn(ZhashxDeserializerFn inner) {
        return inner != null ? new _ZhashxDeserializerFn(inner) : null;
    }


    public long self;

    /*
    Create a new, empty hash container
    */
    native static long __new ();
    public Zhashx () {
        /*  TODO: if __new fails, self is null...            */
        self = __new ();
    }
    public Zhashx (long pointer) {
        self = pointer;
    }
    /*
    Unpack binary frame into a new hash table. Packed data must follow format
    defined by zhashx_pack. Hash table is set to autofree. An empty frame
    unpacks to an empty hash table.
    */
    native static long __unpack (long frame);
    public static Zhashx unpack (Zframe frame) {
        return new Zhashx (__unpack (frame.self));
    }
    /*
    Same as unpack but uses a user-defined deserializer function to convert
    a longstr back into item format.
    */
    native static long __unpackOwn (long frame, long deserializer);
    public static Zhashx unpackOwn (Zframe frame, _ZhashxDeserializerFn deserializer) {
        return new Zhashx (__unpackOwn (frame.self, deserializer.getAddress()));
    }
    /*
    Destroy a hash container and all items in it
    */
    native static void __destroy (long self);
    @Override
    public void close () {
        __destroy (self);
        self = 0;
    }

    /*
    Insert item into hash table with specified key and item.
    If key is already present returns -1 and leaves existing item unchanged
    Returns 0 on success.
    */
    native static int __insert (long self, long key, long item);
    public int insert (long key, long item) {
        return __insert (self, key, item);
    }
    /*
    Update or insert item into hash table with specified key and item. If the
    key is already present, destroys old item and inserts new one. If you set
    a container item destructor, this is called on the old value. If the key
    was not already present, inserts a new item. Sets the hash cursor to the
    new item.
    */
    native static void __update (long self, long key, long item);
    public void update (long key, long item) {
        __update (self, key, item);
    }
    /*
    Remove an item specified by key from the hash table. If there was no such
    item, this function does nothing.
    */
    native static void __delete (long self, long key);
    public void delete (long key) {
        __delete (self, key);
    }
    /*
    Delete all items from the hash table. If the key destructor is
    set, calls it on every key. If the item destructor is set, calls
    it on every item.
    */
    native static void __purge (long self);
    public void purge () {
        __purge (self);
    }
    /*
    Return the item at the specified key, or null
    */
    native static long __lookup (long self, long key);
    public long lookup (long key) {
        return __lookup (self, key);
    }
    /*
    Reindexes an item from an old key to a new key. If there was no such
    item, does nothing. Returns 0 if successful, else -1.
    */
    native static int __rename (long self, long oldKey, long newKey);
    public int rename (long oldKey, long newKey) {
        return __rename (self, oldKey, newKey);
    }
    /*
    Set a free function for the specified hash table item. When the item is
    destroyed, the free function, if any, is called on that item.
    Use this when hash items are dynamically allocated, to ensure that
    you don't have memory leaks. You can pass 'free' or NULL as a free_fn.
    Returns the item, or NULL if there is no such item.
    */
    native static long __freefn (long self, long key, long freeFn);
    public long freefn (long key, _ZhashxFreeFn freeFn) {
        return __freefn (self, key, freeFn.getAddress());
    }
    /*
    Return the number of keys/items in the hash table
    */
    native static long __size (long self);
    public long size () {
        return __size (self);
    }
    /*
    Return a zlistx_t containing the keys for the items in the
    table. Uses the key_duplicator to duplicate all keys and sets the
    key_destructor as destructor for the list.
    */
    native static long __keys (long self);
    public Zlistx keys () {
        return new Zlistx (__keys (self));
    }
    /*
    Return a zlistx_t containing the values for the items in the
    table. Uses the duplicator to duplicate all items and sets the
    destructor as destructor for the list.
    */
    native static long __values (long self);
    public Zlistx values () {
        return new Zlistx (__values (self));
    }
    /*
    Simple iterator; returns first item in hash table, in no given order,
    or NULL if the table is empty. This method is simpler to use than the
    foreach() method, which is deprecated. To access the key for this item
    use zhashx_cursor(). NOTE: do NOT modify the table while iterating.
    */
    native static long __first (long self);
    public long first () {
        return __first (self);
    }
    /*
    Simple iterator; returns next item in hash table, in no given order,
    or NULL if the last item was already returned. Use this together with
    zhashx_first() to process all items in a hash table. If you need the
    items in sorted order, use zhashx_keys() and then zlistx_sort(). To
    access the key for this item use zhashx_cursor(). NOTE: do NOT modify
    the table while iterating.
    */
    native static long __next (long self);
    public long next () {
        return __next (self);
    }
    /*
    After a successful first/next method, returns the key for the item that
    was returned. This is a constant string that you may not modify or
    deallocate, and which lasts as long as the item in the hash. After an
    unsuccessful first/next, returns NULL.
    */
    native static long __cursor (long self);
    public long cursor () {
        return __cursor (self);
    }
    /*
    Add a comment to hash table before saving to disk. You can add as many
    comment lines as you like. These comment lines are discarded when loading
    the file. If you use a null format, all comments are deleted.
    */
    native static void __comment (long self, String format);
    public void comment (String format) {
        __comment (self, format);
    }
    /*
    Save hash table to a text file in name=value format. Hash values must be
    printable strings; keys may not contain '=' character. Returns 0 if OK,
    else -1 if a file error occurred.
    */
    native static int __save (long self, String filename);
    public int save (String filename) {
        return __save (self, filename);
    }
    /*
    Load hash table from a text file in name=value format; hash table must
    already exist. Hash values must printable strings; keys may not contain
    '=' character. Returns 0 if OK, else -1 if a file was not readable.
    */
    native static int __load (long self, String filename);
    public int load (String filename) {
        return __load (self, filename);
    }
    /*
    When a hash table was loaded from a file by zhashx_load, this method will
    reload the file if it has been modified since, and is "stable", i.e. not
    still changing. Returns 0 if OK, -1 if there was an error reloading the
    file.
    */
    native static int __refresh (long self);
    public int refresh () {
        return __refresh (self);
    }
    /*
    Serialize hash table to a binary frame that can be sent in a message.
    The packed format is compatible with the 'dictionary' type defined in
    http://rfc.zeromq.org/spec:35/FILEMQ, and implemented by zproto:

       ; A list of name/value pairs
       dictionary      = dict-count *( dict-name dict-value )
       dict-count      = number-4
       dict-value      = longstr
       dict-name       = string

       ; Strings are always length + text contents
       longstr         = number-4 *VCHAR
       string          = number-1 *VCHAR

       ; Numbers are unsigned integers in network byte order
       number-1        = 1OCTET
       number-4        = 4OCTET

    Comments are not included in the packed data. Item values MUST be
    strings.
    */
    native static long __pack (long self);
    public Zframe pack () {
        return new Zframe (__pack (self));
    }
    /*
    Same as pack but uses a user-defined serializer function to convert items
    into longstr.
    */
    native static long __packOwn (long self, long serializer);
    public Zframe packOwn (_ZhashxSerializerFn serializer) {
        return new Zframe (__packOwn (self, serializer.getAddress()));
    }
    /*
    Make a copy of the list; items are duplicated if you set a duplicator
    for the list, otherwise not. Copying a null reference returns a null
    reference. Note that this method's behavior changed slightly for CZMQ
    v3.x, as it does not set nor respect autofree. It does however let you
    duplicate any hash table safely. The old behavior is in zhashx_dup_v2.
    */
    native static long __dup (long self);
    public Zhashx dup () {
        return new Zhashx (__dup (self));
    }
    /*
    Set a user-defined deallocator for hash items; by default items are not
    freed when the hash is destroyed.
    */
    native static void __setDestructor (long self, long destructor);
    public void setDestructor (_ZhashxDestructorFn destructor) {
        __setDestructor (self, destructor.getAddress());
    }
    /*
    Set a user-defined duplicator for hash items; by default items are not
    copied when the hash is duplicated.
    */
    native static void __setDuplicator (long self, long duplicator);
    public void setDuplicator (_ZhashxDuplicatorFn duplicator) {
        __setDuplicator (self, duplicator.getAddress());
    }
    /*
    Set a user-defined deallocator for keys; by default keys are freed
    when the hash is destroyed using free().
    */
    native static void __setKeyDestructor (long self, long destructor);
    public void setKeyDestructor (_ZhashxDestructorFn destructor) {
        __setKeyDestructor (self, destructor.getAddress());
    }
    /*
    Set a user-defined duplicator for keys; by default keys are duplicated
    using strdup.
    */
    native static void __setKeyDuplicator (long self, long duplicator);
    public void setKeyDuplicator (_ZhashxDuplicatorFn duplicator) {
        __setKeyDuplicator (self, duplicator.getAddress());
    }
    /*
    Set a user-defined comparator for keys; by default keys are
    compared using strcmp.
    The callback function should return zero (0) on matching
    items.
    */
    native static void __setKeyComparator (long self, long comparator);
    public void setKeyComparator (_ZhashxComparatorFn comparator) {
        __setKeyComparator (self, comparator.getAddress());
    }
    /*
    Set a user-defined hash function for keys; by default keys are
    hashed by a modified Bernstein hashing function.
    */
    native static void __setKeyHasher (long self, long hasher);
    public void setKeyHasher (_ZhashxHashFn hasher) {
        __setKeyHasher (self, hasher.getAddress());
    }
    /*
    Make copy of hash table; if supplied table is null, returns null.
    Does not copy items themselves. Rebuilds new table so may be slow on
    very large tables. NOTE: only works with item values that are strings
    since there's no other way to know how to duplicate the item value.
    */
    native static long __dupV2 (long self);
    public Zhashx dupV2 () {
        return new Zhashx (__dupV2 (self));
    }
    /*
    Self test of this class.
    */
    native static void __test (boolean verbose);
    public static void test (boolean verbose) {
        __test (verbose);
    }
}
