/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
package org.zeromq.czmq;

public class Zcertstore implements AutoCloseable{
    static {
        try {
            System.loadLibrary ("czmqjni");
        }
        catch (Exception e) {
            System.exit (-1);
        }
    }

    public interface ZcertstoreLoader {
        void  callback (Zcertstore self);
    }

    public static class _ZcertstoreLoader implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZcertstoreLoader inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZcertstoreLoader (ZcertstoreLoader inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.VOID, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.POINTER}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            inner.callback(new Zcertstore(buffer.getAddress(0)));
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZcertstoreLoader zcertstore_loader(ZcertstoreLoader inner) {
        return inner != null ? new _ZcertstoreLoader(inner) : null;
    }

    public interface ZcertstoreDestructor {
        long  callback (long selfP);
    }

    public static class _ZcertstoreDestructor implements AutoCloseable, com.kenai.jffi.Closure {
        private final ZcertstoreDestructor inner;
        private final com.kenai.jffi.Closure.Handle handle;

        public _ZcertstoreDestructor (ZcertstoreDestructor inner) {
            this.inner = inner;
            this.handle = com.kenai.jffi.ClosureManager.getInstance().newClosure(this, com.kenai.jffi.Type.SLONG, new com.kenai.jffi.Type[] {com.kenai.jffi.Type.SLONG}, com.kenai.jffi.CallingConvention.DEFAULT);
            this.handle.setAutoRelease(false);
        }

        @Override
        public void close () {
            handle.dispose();
        }

        @Override
        public void invoke(com.kenai.jffi.Closure.Buffer buffer) {
            long ret;
            ret =  inner.callback(buffer.getLong(0));
            buffer.setLongReturn(ret);
        }

        public long getAddress () {
            return handle.getAddress();
        }
    }

    public static _ZcertstoreDestructor zcertstore_destructor(ZcertstoreDestructor inner) {
        return inner != null ? new _ZcertstoreDestructor(inner) : null;
    }


    public long self;

    /*
    Create a new certificate store from a disk directory, loading and
    indexing all certificates in that location. The directory itself may be
    absent, and created later, or modified at any time. The certificate store
    is automatically refreshed on any zcertstore_lookup() call. If the
    location is specified as NULL, creates a pure-memory store, which you
    can work with by inserting certificates at runtime.
    */
    native static long __new (String location);
    public Zcertstore (String location) {
        /*  TODO: if __new fails, self is null...            */
        self = __new (location);
    }
    public Zcertstore (long pointer) {
        self = pointer;
    }
    /*
    Destroy a certificate store object in memory. Does not affect anything
    stored on disk.
    */
    native static void __destroy (long self);
    @Override
    public void close () {
        __destroy (self);
        self = 0;
    }

    /*
    Override the default disk loader with a custom loader fn.
    */
    native static void __setLoader (long self, long loader, long destructor, long state);
    public void setLoader (_ZcertstoreLoader loader, _ZcertstoreDestructor destructor, long state) {
        __setLoader (self, loader.getAddress(), destructor.getAddress(), state);
    }
    /*
    Look up certificate by public key, returns zcert_t object if found,
    else returns NULL. The public key is provided in Z85 text format.
    */
    native static long __lookup (long self, String publicKey);
    public Zcert lookup (String publicKey) {
        return new Zcert (__lookup (self, publicKey));
    }
    /*
    Insert certificate into certificate store in memory. Note that this
    does not save the certificate to disk. To do that, use zcert_save()
    directly on the certificate. Takes ownership of zcert_t object.
    */
    native static void __insert (long self, long certP);
    public void insert (Zcert certP) {
        __insert (self, certP.self);
    }
    /*
    Empty certificate hashtable. This wrapper exists to be friendly to bindings,
    which don't usually have access to struct internals.
    */
    native static void __empty (long self);
    public void empty () {
        __empty (self);
    }
    /*
    Print list of certificates in store to logging facility
    */
    native static void __print (long self);
    public void print () {
        __print (self);
    }
    /*
    Return a list of all the certificates in the store.
    The caller takes ownership of the zlistx_t object and is responsible
    for destroying it.  The caller does not take ownership of the zcert_t
    objects.
    */
    native static long __certs (long self);
    public Zlistx certs () {
        return new Zlistx (__certs (self));
    }
    /*
    Self test of this class
    */
    native static void __test (boolean verbose);
    public static void test (boolean verbose) {
        __test (verbose);
    }
}
